#include <iostream>
#include <stdio.h> 
#include <vector> 

using namespace std;

// 왜 goto를 옛날에는 쓸 수밖에 없었나. 

int do_something()
{
//	char* buffer1 = NULL; 
//	char* buffer2 = NULL; 
//
//	FILE* file = NULL; 
//
//	buffer1 = malloc(128); 
//	if (!buffer1) goto cleanup; 
//
//	buffer2 = malloc(256); 
//	if (!buffer2) goto cleanup; 
//
//	// 작업 수행 
//	cout << "작업 성공" << endl; 
//
//cleanup : 
//	if (file) fclose(file); 
//	if (buffer2) free(buffer2); 
//	if (buffer1) free(buffer1);
//	return (file && buffer1 && buffer2) ? 0 : -1; 

}

int do_somethings() {
	// RAII 
	// 자원 관리 자동화 
	// 이미 암시적으로 소멸자가 존재함. 
	// 가비지 컬렉션을 대체하기 위해 나온 클래스. 

	//vector<char> buffer1(128); 
	//vector<char> buffer2(256); 
	//
	// 명확하게 사용되는 방법을 알아야 한다. 
	//ifstream file("input.text"); 
	//
	//if (!file) return -1; // 자동으로 해제가 된다. 
	//return 0;

	// 왜 이렇게 써야만 했는가? 왜 이렇게 설계를 해야만 했는가? 
	// 1. C++ 과 C# 의 차이 
	// 2. 가비지 컬렉션과 RAII -> 꼬리 질문(명확하게 알고 있는 지 아닌지 체크하기 위한 질문) 
	// 3. 


}

//class MyClass {
//	MyClass() {
//		cout << "자원 획득" << endl; 
//	}
//	MyClass() {
//		cout << "자원 삭제" << endl; 
//	}
//};

// char* buf = malloc(1024); 
// if (!buf) return -1; 
// some_func(); // 메모리 누수. 해제 해주지 않았기 때문. 
// free(buf): 



void example() {
	vector<char> buf(100); 
	//som_function(); // 예외. 
	// 메모리 누수가 일어나지 않음. 
	// 스코프를 나가면 자동으로 소멸자 생성!!
}


// 최신 버전 

#include <thread> 







#include <any>
using namespace std;

int main()
{
	cout << "나는 등장하지롱~" << endl;

	goto hello; // hello 레이블 이름으로 이동해주세요. 

	cout << "나는 등장하지 않지롱~" << endl; // goto 다음 문은 실행 자체가 안되기 때문에 이렇게 사용하면 안됀다. 

hello: // 레이블 설정 
	cout << "나는 등장할까? " << endl;


	cout << endl;
	cout << "--------------------------------------------------------------------" << endl;

	//FILE* fp = fopen("test.txt", "r");
	//if (!fp) { // 검증할 것 자체가 없기 때문에, 바로 error 로 넘어간다. 
	//	goto error; 
	//}

	//fclose(fp);
	//return 0;

error:
	printf("파일 열기 실패!\n");
	return 1;

	cout << "--------------------------------------------------------------------" << endl;
	// goto를 사용해선 안돼는 이유 
	// goto 는 코드를 복잡하고, 읽기 어렵게 할 수 있다. 
	// 하지만, 대부분의 경우, if , while, for, break, continue, 함수 등으로 대체하는 것이 좋다. 

	// 주의점 
	  // 1. goto 는 리소스 해제, 에러 복구 등에서 조건부로 사용할 수 있지만, 
	  //	남용은 피해야 한다.  
	  // 2. 함수 안에서만 사용이 가능하기 때문에, 함수 바깥으로는 점프는 안됀다. {} 안에서만 제한이 되어있다. 

	cout << "--------------------------------------------------------------------" << endl;

	// RAII 스코프 기반 
	{
		//MyClass* obj; // 자동으로 소멸됨. 
		//사용 중 
		// 스코프를 기준 안에서 메모리를 사용. 
		// 스코프 밖으로 나가면, 그 때부터 메모리가 자동으로 해제. 
		
		//vector<int> vec(10); 
	}

	cout << "------------------------------최신 버전--------------------------------------" << endl;

	bool is_debug() noexcept; // 디버깅 시스템 


	cout << "------------------------------Any--------------------------------------" << endl;

	

}

//장점 
// 1. 코드의 간결화 
//    : 간단한 오류를 한번에 정리 작업을 할 수 있다. 즉, 중복된 코드를 피하고, 코드의 흐름을 단순화 한다. 

// 2. 중첩된 루프 탈출 
//    : 복잡하게 중첩된 루프에서 특정 조건을 만족하면 모든 루프를 벗어나야 할 때 goto 가 유용 

// 3. 키워드 사용으로 함수에서 조건에 따른 결과값이 어떻게 나올 지 예측이 가능. 즉, 코드의 흐름이 명확해진다. 

// 4. 상태 기계와 같은 패턴에서, goto를 사용해 코드의 흐름을 명확히 할 수 있음. 특정 상태로 직접 점프할 때 가독성을 높인다. 

// 중첩된 경우, 실행한 함수 이후의 다른 함수는 실행하지 않는다. 

// 5. 중복 없이 자원 해제. 
// : 여러 리소스 등을 순차적으로 해제해야할 때, 하나의 함수로 바로 이동해 삭제시킬 수 있다. 



// 키워드. 
// goto 문이 사용하는 키워드를 통해서 함수 또는 출력, 로직 을 실행 함으로서,  
// 코드의 흐름을 단순화 하고, 빠르게 실행 속도를 높일 수 있되, 명확한 사용 목적이 있을 때 사용해야 한다. 

// 깊게 중첩된 루프가 몇번을 사용되든, 한번에 탈출할 수 있다. 
// 아주 단순한 상태 머신을 빠르게 구현할 때 
// 
// 현재의 c++ 컴파일러가 함수 인라이닝과 최적화를 워낙 잘해주고, 깔끔한 예외 / 에러 처리가 가능하기 때문에, 
// 가독성 / 유지 보수 라는 측면에서는 함수가 더 낮다. 



// 단점 
 // 1. 가독성 저하 
 //  : 코드 흐름을 비논리적으로 만들고, 흐름을 따라가기 어렵게 할 수 있다. 특히나 복잡한 코드에서는 디버깅과 유지보수를 어렵게 한다. 

 // 2. 디버깅의 어려움 
 //  : goto를 많이 사용할 수록 흐름이 불분명해지기 때문에 디버깅이 어려워진다. 코드가 예상치 못한 위치로 이동할 수 있기 때문. 

 // 3. 비구조적 프로그래밍 
 //  : 구조를 깨트릴 가능성 높음. 장기적으로 유지보수에 부정적인 영향을 준다. 스파게티 코드로 만들어버릴 가능성이 높음. 

 // 4. 초기화 / 소멸자 호출 누락 
 //  : 객체가 제대로 초기화 되지 않거나 파괴되지 않아 리소스 누수가 발생 할 수 있음. 

